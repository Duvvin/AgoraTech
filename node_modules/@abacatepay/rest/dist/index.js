// src/errors.ts
class AbacatePayError extends Error {
  message;
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "AbacatePayError";
  }
}

class HTTPError extends Error {
  route;
  message;
  constructor(route, message) {
    super(message);
    this.route = route;
    this.message = message;
    this.name = `AbacatePayError(${route})`;
  }
}

// src/utils.ts
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var RATE_LIMIT_STATUS_CODE = 429;
var RETRYABLE_STATUS = [
  408,
  425,
  RATE_LIMIT_STATUS_CODE,
  500,
  502,
  503,
  504
];
var BASE_DELAY_MS = 300;
var MAX_DELAY_MS = 1e4;
var backoff = (attempt) => {
  const exp = Math.min(MAX_DELAY_MS, BASE_DELAY_MS * 2 ** attempt);
  const jitter = Math.random() * exp * 0.3;
  return Math.floor(exp + jitter);
};

// src/client.ts
var FIVE_SEC_IN_MS = 5000;

class REST {
  options;
  constructor(options = {}) {
    this.options = options;
  }
  setSecret(secret) {
    this.options.secret = secret;
    return this;
  }
  get(route, options) {
    return this.makeRequest(route, { ...options, method: "GET" });
  }
  post(route, options) {
    return this.makeRequest(route, { ...options, method: "POST" });
  }
  delete(route, options) {
    return this.makeRequest(route, { ...options, method: "DELETE" });
  }
  put(route, options) {
    return this.makeRequest(route, { ...options, method: "PUT" });
  }
  patch(route, options) {
    return this.makeRequest(route, { ...options, method: "PATCH" });
  }
  async makeRequest(route, options, attempt = 0) {
    const url = this.makeURL(route, options.query);
    const timeout = this.options.timeout ?? FIVE_SEC_IN_MS;
    try {
      const response = await fetch(url, {
        method: options.method,
        signal: AbortSignal.timeout(timeout),
        headers: this.makeHeaders(options.headers),
        body: "body" in options ? JSON.stringify(options.body) : null
      });
      if (!response.ok)
        return this.handleError({ route, attempt, options, response });
      return this.process(response);
    } catch (err) {
      const isTimeoutError = err?.name === "TimeoutError";
      if (isTimeoutError)
        throw new HTTPError(route, `Your request timed out (Waited for ${timeout}ms)`);
      throw new HTTPError(route, `${err}`);
    }
  }
  async handleError({
    route,
    options,
    attempt,
    response
  }) {
    if (RETRYABLE_STATUS.includes(response.status)) {
      const { onRateLimit, retry = options.retry ?? { max: 3 } } = this.options;
      if (attempt >= retry.max)
        throw new HTTPError(route, `${retry.max} attempts were performed, all failed`);
      if (response.status === RATE_LIMIT_STATUS_CODE && onRateLimit)
        await onRateLimit(response);
      const delay = (retry.backoff ?? backoff)(attempt);
      await sleep(delay);
      return this.makeRequest(route, options, attempt + 1);
    }
    const { error } = await response.json();
    throw new AbacatePayError(error);
  }
  async process(response) {
    const NO_CONTENT_STATUS_CODE = 204;
    if (response.status === NO_CONTENT_STATUS_CODE)
      return;
    const { data, error } = await response.json();
    if (error)
      throw new AbacatePayError(error);
    return data;
  }
  makeURL(route, query) {
    const base = `${this.options.base ?? "https://api.abacatepay.com/v"}${this.options.version ?? 1}${route}`;
    return query ? `${base}?${new URLSearchParams(query)}` : base;
  }
  makeHeaders(custom) {
    const { secret } = this.options;
    if (!secret)
      throw new AbacatePayError("Your secret key is undefined. Use REST.setSecret(secret)");
    return {
      "Content-Type": "application/json",
      Authorization: `Bearer ${secret}`,
      ...this.options.headers,
      ...custom
    };
  }
}
export {
  REST,
  HTTPError,
  AbacatePayError
};
